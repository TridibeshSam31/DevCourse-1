//starting Postgres SQL 

1. What is PostgreSQL?

PostgreSQL (a.k.a. Postgres) is an open-source, object-relational database.

Unlike MySQL, itâ€™s feature-rich, standards-compliant, and highly extensible.

Think of it as a data brain that:

Stores data (rows/columns, JSON, geospatial, etc.)

Lets you query with SQL

Supports transactions (safe, consistent changes)

Scales from small apps â†’ enterprise-level systems.


Itâ€™s not just a relational DB â†’ it also handles:

JSON documents (NoSQL style)

Full-text search

Geospatial queries (PostGIS)

Custom data types and functions

Thatâ€™s why startups and big companies love it (Instagram, Uber, Spotify, etc.)



2. PostgreSQL Architecture (How it works internally)

Understanding the core:

1.Client â†’ You (via SQL, app, or tool like pgAdmin).
2.Postgres Server (postmaster) â†’ Manages DB processes.
3.Shared Buffers â†’ Where frequently used data is cached (RAM).
4.WAL (Write-Ahead Log) â†’ Before any change is made to data files, itâ€™s written to WAL for crash recovery.
5.Background Processes:

Autovacuum â†’ Cleans dead rows.

Checkpointer â†’ Flushes dirty pages to disk.

BGWriter â†’ Writes buffers in background.

WAL Writer â†’ Ensures durability.


3. PostgreSQL Data Storage

Postgres stores data in a cluster â†’ contains databases â†’ contain schemas â†’ contain tables, views, indexes.'

ab in bhaari shabdo ka mtlb kya hai  ?? what is cluster

Cluster = all your DBs on one server.
Database = collection of schemas.
Schema = namespace (like folders).
Table = actual data in rows/columns.
Tuple = one row.
Index = shortcut for fast searching.

4. PostgreSQL Data Types

Postgres supports a ton of data types:

Numeric: INT, BIGINT, FLOAT, NUMERIC (arbitrary precision).
Textual: CHAR, VARCHAR, TEXT.
Boolean: TRUE/FALSE.
Date/Time: DATE, TIME, TIMESTAMP, INTERVAL.
UUID: unique identifiers.
Array: e.g., int[].
JSON/JSONB: Store semi-structured docs.
HSTORE: Key-value store.
Geospatial (PostGIS): POINT, POLYGON, etc.
Custom Types: You can define your own.

5. PostgreSQL SQL Fundamentals

DDL (Data Definition Language)


1.CREATE DATABASE mydb;
2.CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT, email TEXT UNIQUE);
3.ALTER TABLE users ADD COLUMN age INT;
4.DROP TABLE users;

DML (Data Manipulation Language)

1.INSERT INTO users (name, email) VALUES ('Alice', 'alice@email.com');
2.UPDATE users SET age = 25 WHERE id = 1;
3.DELETE FROM users WHERE id = 2;

DQL (Data Query Language)

1.SELECT * FROM users;

2.SELECT name, email FROM users WHERE age > 18 ORDER BY age;

3.SELECT COUNT(*), AVG(age) FROM users;

Joins  
1.INNER JOIN â†’ common rows
2.LEFT JOIN â†’ everything from left + match
3.RIGHT JOIN â†’ everything from right + match
4.FULL OUTER JOIN â†’ everything
5.SELF JOIN â†’ join table with itself




ðŸ”¹ 6. PostgreSQL Advanced Features
âœ… Constraints

Primary Key: unique row id.
Foreign Key: reference another table.
Unique: no duplicates.
Check: conditions.

Not Null: must have value.

âœ… Indexes

B-Tree (default, for equality/range).
Hash Index (faster equality).
GIN / GiST (for JSON, full-text, geo).
BRIN (for huge sequential data).

âœ… Transactions

Postgres follows ACID:

Atomicity: all or nothing
Consistency: valid state
Isolation: no dirty reads
Durability: survives crashes

Example:
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;


Views & Materialized Views
1.View = saved query.
2.Materialized View = saved query + data snapshot.


Triggers & Functions

Functions in SQL/PLpgSQL.
Triggers = execute on INSERT/UPDATE/DELETE.


7. PostgreSQL Performance Tuning

1.Use EXPLAIN ANALYZE to debug queries.
2.Normalize schema (remove redundancy).
3.Use indexes wisely (too many = slow inserts).
4.Partition big tables.
5.Use caching (Redis) with Postgres for scalability.


8. PostgreSQL Extensions (Big Strength)

PostGIS â†’ Geospatial.
pg_cron â†’ Scheduling jobs.
TimescaleDB â†’ Time-series.
pg_stat_statements â†’ Query analysis.
pgvector â†’ AI/ML embeddings storage.

ðŸ”¹ 9. PostgreSQL in Development

Works great with Node.js, Python, Java, Go.
ORMs: Prisma, Sequelize, TypeORM.
Can handle both OLTP (transactions) and OLAP (analytics) workloads.

ðŸ”¹ 10. PostgreSQL vs Others

MySQL â†’ simpler, but less advanced.
MongoDB â†’ good for JSON-heavy, but Postgres can do both relational + JSON.
Oracle/SQL Server â†’ paid, Postgres is free but competitive.

yaha tkk thi hmari basic info regarding postgress database rest isme deep dive maarte hai ki hum isse kaise use krte hai 



ab yeh baat krte hai ki lecture mai sir ne kya btaya 

Types of Databases:
There are a few types of databases, all service different types of use-cases
NoSQL databases 
1.Store data in a schema-less fashion. Extremely lean and fast way to store data. 
2.Examples - MongoDB, 


Graph databases 
Data is stored in the form of a graph. Specially useful in cases where relationships need to be stored (social networks
Examples - Neo4j


Vector databases
1.Stores data in the form of vectors
2.Useful in Machine learning
Examples - Pinecone
 
SQL databases
1.Stores data in the form of rows
2.Most full stack applications will use this
Examples - MySQL, Postgres
 

Now the question  arises why should we use Nosql and why we should not use it

so why should we use it  ?
Itâ€™s schemaless properties make it ideal to for bootstraping a project fast.


why should we not use it ?
 as our app grows, this property makes it very easy for data to get curropted
 

what is schemaless?
Different rows can have different schema (keys/types)
Now what problem does it creates
1.Can lead to inconsistent database
2.Can cause runtime errors 
3.It Is too flexible for an app that needs strictness

But yes we can change schema very easily and it can move very fast

Important Point 
you might think that mongoose does add strictness to the codebase because we used to define a schema there. 
That strictness is present at the Node.js level, not at the DB level. You can still put in erroneous data in the database that doesnâ€™t follow that schema.


Why should we use SQL then ?? What so special in it

SQL databases have a strict schema. They require you to
1.Define your schema
2.Put in data that follows that schema
3.Update the schema as your app changes and perform migrations

Migration means to convert from one form to another we will see ahead 

So there are 4 parts when using an SQL database (not connecting it to Node.js, just running it and putting data in it)
1.Running the database.
2.Using a library that letâ€™s you connect and put data in it.
3.Creating a table and defining itâ€™s schema.
4.Run queries on the database to interact with the data (Insert/Update/Delete)



I am running the prostgress commands using  docker windows 
so going to the next step

Using a library that letâ€™s you connect and put data in it.
1.psql
psql is a terminal-based front-end to PostgreSQL. It provides an interactive command-line interface to the PostgreSQL (or TimescaleDB) database. With psql, you can type in queries interactively, issue them to PostgreSQL, and see the query results.

How to connect to your database?
psql Comes bundled with postgresql. You donâ€™t need it for this tutorial. We will directly be communicating with the database from Node.js


2. pg
pg is a Node.js library that you can use in your backend app to store data in the Postgres DB (similar to mongoose). 


Tables in SQL
A single database can have multiple tables inside. Think of them as collections in a MongoDB database.

Until now, we have a database that we can interact with. The next step in case of postgres is to define the schema of your tables.
SQL stands for Structured query language. It is a language in which you can describe what/how you want to put data in the database.


Suppose We want to create a table in sql so we will write something like this 

CREATE TABLE users(
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
)


LETS UNDERSTAND EACH STATEMENT HERE


1.CREATE TABLE users
This command initiates the creation of a new table in the database named users.

2.id SERIAL PRIMARY KEY
Id: The name of the first column in the users table typically used a unique identifier for each  row (user)
similar to _id in MongoDB
SERIAL: a postgresSQL-specific data type for creating an auto-incrementing integer. Every time a new roe is inserrted this value automatically increments,ensuring each user has a unique id
PRIMARY KEY : This constraint specifies that the id column is the primary key for the table, meaning it uniquely identifies each row. Values in this column must be unique and not null.


3.email VARCHAR(255) UNIQUE NOT NULL,
email: The name of the second column, intended to store the user's username.
VARCHAR(50): A variable character string data type that can store up to 50 characters. It's used here to limit the length of the username.
UNIQUE: This constraint ensures that all values in the username column are unique across the table. No two users can have the same username.
NOT NULL: This constraint prevents null values from being inserted into the username column. Every row must have a username value.
4. password VARCHAR(255) NOT NULL
Same as above, can be non uniqye
5. created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
created_at: The name of the fifth column, intended to store the timestamp when the user was created.
TIMESTAMP WITH TIME ZONE: This data type stores both a timestamp and a time zone, allowing for the precise tracking of when an event occurred, regardless of the user's or server's time zone.
DEFAULT CURRENT_TIMESTAMP: This default value automatically sets the created_at column to the date and time at which the row is inserted into the table, using the current timestamp of the database server.
 
ðŸ’¡
If you have access to a database right now, try running this command to create a simple table in there

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

Then try running 
\dt;
to see if the table has been created or not

i DID THIS USING DOCKER 

iNTERACTING WITH THE DATABASE

1.INSERT
INSERT INTO users (username, email, password)
VALUES ('username_here', 'user@example.com', 'user_password');

we didn't have to specify the id because it auto increments 

2.UPDATE
UPDATE users
SET password = 'new_password'
WHERE email = 'user@example.com';

3.DELETE
DELETE FROM users
WHERE id = 1;

4.SELECT
SELECT * FROM users;
WHERE id = 1;


How to do queries from a node.js app ??

In the end, postgres exposes a protocol that someone needs to talk to be able to send these commands (update, delete) to the database.
psql  is one such library that takes commands from your terminal and sends it over to the database.
To do the same in a Node.js , you can use one of many Postgres clients 

pg library a non blocking PostgreSQL client for node.js

for connectiong to db
import { Client } from 'pg'
 
const client = new Client({
  host: 'my.database-server.com',
  port: 5334,
  database: 'database-name',
  user: 'database-user',
  password: 'secretpassword!!',
})

client.connect()

so we did similar in our cloudinary saas project and even this is a basic syntax


for querying 
const result = await client.query('SELECT * FROM USERS;')
console.log(result)


suppose we want to write a function to create a users table in our db

import { Client } from 'pg'
 
const client = new Client({
    connectingString:process.env.DATABASE_URL


})

async function createTable(){
    we will connect with db 
    await client.connect()
    const result = await client.query('
      CREATE TABLE users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            password VARCHAR(255) NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
    )
 console.log(result)

}

createUsersTable();


Remaining are joins and relationships in mongodb I will do that after taking joins class offline class

 
 
 


















